I"Æ<p><strong>kvm_vcpu_fops</strong> å¯¹åº”vcpu fdï¼Œåœ¨create_vcpu_fdè®¾ç½®</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static const struct file_operations kvm_vcpu_fops = { 
        .release        = kvm_vcpu_release,
        .unlocked_ioctl = kvm_vcpu_ioctl,
        .mmap           = kvm_vcpu_mmap,
        .llseek         = noop_llseek,
        KVM_COMPAT(kvm_vcpu_compat_ioctl),
};
</code></pre></div></div>

<p>å¯¹vcpuæ‰§è¡ŒKVM_RUNåï¼Œkvm_arch_vcpu_ioctl_runæ£€æŸ¥å„ç§å‚æ•°ï¼Œç„¶åæ‰§è¡Œvcpu_run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kvm_vcpu_ioctl
	KVM_RUNï¼š
	kvm_arch_vcpu_ioctl_run(vcpu);
		vcpu-&gt;arch.complete_userspace_io
		kvm_x86_vcpu_pre_run
		vcpu_run





vcpu_run
	for(;;) {
        if (kvm_vcpu_running(vcpu)) {
            r = vcpu_enter_guest(vcpu);   //r&gt;0ç»§ç»­æ‰§è¡Œæ­»å¾ªç¯
        } else {
            r = vcpu_block(vcpu);
        }

		if (r &lt;= 0)
			break;
    }
</code></pre></div></div>

<p><strong>vcpu_enter_guest</strong>æ˜¯æ ¸å¿ƒå‡½æ•°</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vcpu_enter_guest
	for(;;) {
		//æ‰§è¡Œrunå‡½æ•°ï¼Œå³vmx_vcpu_runï¼ŒåŠ è½½å¯„å­˜å™¨ï¼Œè¿›å…¥non_rootæ¨¡å¼
		//åœ¨vmx_vcpu_runé€€å‡ºå‰ï¼Œæ‰§è¡Œå¿«é€Ÿå‡½æ•°vmx_exit_handlers_fastpath
		exit_fastpath = static_call(kvm_x86_vcpu_run)(vcpu); 
		
		//å¦‚æœå¿«é€Ÿå‡½æ•°è¿”å›å€¼ä¸è®©é‡æ–°è¿›å…¥guestï¼Œåˆ™break
        if (likely(exit_fastpath != EXIT_FASTPATH_REENTER_GUEST))
        	break;

		if (kvm_lapic_enabled(vcpu))
			static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);

		if (unlikely(kvm_vcpu_exit_request(vcpu))) {
			exit_fastpath = EXIT_FASTPATH_EXIT_HANDLED;
			break;
		}

	}
	static_call(kvm_x86_handle_exit_irqoff)(vcpu);
	
	//æ‰§è¡Œvm_exitçš„æœåŠ¡ç¨‹åºï¼Œå³vmx_handle_exit
	r = static_call(kvm_x86_handle_exit)(vcpu, exit_fastpath);  
</code></pre></div></div>

<p>å¿«é€Ÿå‡½æ•°</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static fastpath_t vmx_exit_handlers_fastpath(struct kvm_vcpu *vcpu)
{
        switch (to_vmx(vcpu)-&gt;exit_reason.basic) {
        //å¿«é€Ÿå‡½æ•°åªå¤„ç†MSR_WRITEå’ŒPREEMPTION_TIMERä¸¤ç§æƒ…å†µ
        case EXIT_REASON_MSR_WRITE:
                return handle_fastpath_set_msr_irqoff(vcpu);
        case EXIT_REASON_PREEMPTION_TIMER:
                return handle_fastpath_preemption_timer(vcpu);
        default:
                return EXIT_FASTPATH_NONE;
        }
}
è¿”å›å€¼æœ‰ä¸‰ç§ç±»å‹
enum exit_fastpath_completion {
        EXIT_FASTPATH_NONE,				//fastå‡½æ•°æœªå¤„ç†
        EXIT_FASTPATH_REENTER_GUEST,	//fastå‡½æ•°å¤„ç†åï¼Œå¯ä»¥ç«‹å³é‡æ–°è¿›å…¥guest
        EXIT_FASTPATH_EXIT_HANDLED,		//fastå‡½æ•°å¤„ç†åï¼Œkvmä¼šç»å†å…¨éƒ¨runloopï¼Œä½†ä¸ä¼šæ‰§è¡Œexit_handler
};

</code></pre></div></div>

<h2 id="vmx_handle_exit">vmx_handle_exit</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vmx_handle_exit
	__vmx_handle_exit
		//flush pml buffer, å¯¼å‡ºè„æ•°æ®
		vmx_flush_pml_buffer
		//æ ¹æ®ä¸åŒçš„EXIT_REASONè°ƒç”¨çœŸæ­£çš„handlerï¼Œå¦‚handle_ioï¼Œhandle_invlpg
		return kvm_vmx_exit_handlers[exit_handler_index](vcpu)
</code></pre></div></div>

<h2 id="exit_reason">exit_reason</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    vcpu-&gt;run-&gt;exit_reason = reason
	å¯¹åº”ç»“æ„ä½“
	struct kvm_vcpuâ€”â€”struct kvm_runâ€”â€”_u32 exit_reason ç”¨äºå‘ŠçŸ¥ç”¨æˆ·æ€é€€å‡ºåŸå› ï¼Œåœ¨å¾ˆå¤šåœ°æ–¹è¿›è¡Œèµ‹å€¼
    
    struct vcpu_vmx *vmx = to_vmx(vcpu);
    union vmx_exit_reason exit_reason = vmx-&gt;exit_reason;
    å¯¹åº”ç»“æ„ä½“ï¼š
    struct kvm_vcpuâ€”â€”struct vcpu_vmxâ€”â€”union vmx_exit_reason  ç”¨äºkvmå†…éƒ¨ä½¿ç”¨
    
    åœ¨vmx-&gt;exit_reason.full = vmcs_read32(VM_EXIT_REASON);ä¸­èµ‹å€¼
</code></pre></div></div>

<p>qemu_mutex_lock_iothread</p>
:ET