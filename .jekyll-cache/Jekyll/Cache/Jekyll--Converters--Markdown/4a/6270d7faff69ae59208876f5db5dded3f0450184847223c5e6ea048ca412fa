I"
<h1 id="分页机制">分页机制</h1>

<h2 id="x86使用4级分页机制">x86使用4级分页机制</h2>

<p>CR3-&gt;PML4-&gt;PDPT-&gt;PD-&gt;PT-&gt;4kPage</p>

<p><img src="PCID.assets/分页机制.jpg" alt="img" /></p>

<p>没有任何加速的情况下，一次线性地址访问需要<strong>4次页表访问</strong>和<strong>一次最终物理地址访问</strong>。</p>

<h2 id="cache加速">Cache加速</h2>

<ul>
  <li>cache物理内存——L1、L2、L3 cache</li>
  <li>缓存页表加速地址转换——TLB和Paging-Structure Cache</li>
  <li>TLB：
    <ul>
      <li>直接将线性地址的高位（即page number）直接转换到物理内存页（即page frame）基地址</li>
      <li>一次索引就可以获取物理地址，只需要<strong>一次最终物理地址访问</strong></li>
    </ul>
  </li>
  <li>Paging-Structure Cache
    <ul>
      <li>缓存地址转换页表，包含PML4E cache、PDPTE cache、PDE cache</li>
      <li>可以将TLB看做是PTE cache，因为TLB可以直接转换为物理地址</li>
    </ul>
  </li>
</ul>

<p><img src="PCID.assets/缓存效果.jpg" alt="img" /></p>

<p><img src="PCID.assets/缓存逻辑.jpg" alt="img" /></p>

<h2 id="不同进程的cache可以同时保存在cache中">不同进程的cache可以同时保存在cache中</h2>

<ul>
  <li>进程切换时不再进行flush操作，且可以保存多个进程的cache，提高性能</li>
  <li>为此引入了PCID（Processor Context ID）</li>
  <li>当CPU内部查找地址转换的cache的时候，会先对cache里面的PCID信息和当前的PCID，即存放的CR3寄存器的11:0的值做比较，只有两个地方的PCID相等，CPU才可能会采用该cache项。</li>
</ul>

<h2 id="pcid也称为asid在linux-中使用asid术语">PCID也称为ASID，在Linux 中使用ASID术语</h2>

<ul>
  <li>将当前分配的ASID存储到单独的结构中，进程需要的时候动态分配给进程</li>
  <li>处于非活动状态的进程将不会分配ASID（大多数休眠进程不会消耗ASID，所有分配的ASID都在相同数据结构中，方便cache）</li>
  <li>Linux仅记住最后TLB_NR_DYN_ASIDS=6个ASID，6个刚好使tlb_state占用2个cache line</li>
</ul>

<pre><code class="language-C">struct tlb_context {    
	u64 ctx_id;    
	u64 tlb_gen; 
};  
struct tlb_state {      .     .     .     
	u16 next_asid;     
	struct tlb_context ctxs[TLB_NR_DYN_ASIDS]; 
}; 
DECLARE_PER_CPU_SHARED_ALIGNED(struct tlb_state, cpu_tlbstate);
</code></pre>

<ul>
  <li>内核中使用ASID，uPCID，kPCID等概念，需要进行区分：
    <ul>
      <li>ASID - [0, TLB_NR_DYN_ASIDS-1]，即0-5, 对应于传统的asid标识。</li>
      <li>kPCID - [1, TLB_NR_DYN_ASIDS]，即1-6,内核态pcid，为实际写入CR3中的id，<strong>实际为asid+1，因为pcid=0有特殊用途</strong>。</li>
      <li>uPCID - [2048 + 1, 2048 + TLB_NR_DYN_ASIDS]，即2049-2054，用户态pcid，<strong>实际为kPCID+2048</strong>，其实就是将PCID中的最高位(也就是CR3中的bit 11)置为1即可。</li>
    </ul>
  </li>
  <li>每个进程都有一个ASID,与kPCID和uPCID关联，它们是实际存储在CR3.PCID中的值。</li>
  <li>每个进程具有两个ASID的原因是为了支持页表隔离（PTI），从而减轻了Meltdown漏洞。</li>
</ul>

<h2 id="linux进程切换">Linux进程切换</h2>

<ul>
  <li>Linux在进程切换时为进程动态分配ASID
    <ul>
      <li>如果线程被中断或执行了系统调用，退出时如果调度到同一线程或同一进程的其他线程，会使用相同的ASID</li>
      <li>如果调度到其他进程，Linux会分配一个其他ASID</li>
    </ul>
  </li>
  <li>同一进程的不同线程可能在不同CPU上获得不同ASID，且进程切换时可能会动态更改</li>
</ul>

<h2 id="tlb-invalidate操作">TLB invalidate操作</h2>

<ul>
  <li>INVLPG 线性地址——invalidate当前PCID中的线性地址对应的TLB</li>
  <li>INVPCID
    <ul>
      <li>0、INVPCID_TYPE_INDIV_ADDR——invalidate单个线性地址</li>
      <li>1、INVPCID_TYPE_SINGLE_CTXT——invalidate指定PCID下的所有地址</li>
      <li>2、INVPCID_TYPE_ALL_INCL_GLOBAL——invalidate所有PCID所有条目包括globals</li>
      <li>
        <p>3、INVPCID_TYPE_ALL_NON_GLOBAL——invalidate所有PCID所有条目不包括globals</p>

        <p>static inline void __invpcid(unsigned long pcid, unsigned long addr,
                             unsigned long type)
    struct { u64 d[2]; } desc = { { pcid, addr } };
    asm volatile(“invpcid %[desc], %[type]”
                 :: [desc] “m” (desc), [type] “r” (type) : “memory”);</p>
      </li>
    </ul>
  </li>
</ul>

<p><img src="PCID.assets/INVPCID指令.png" alt="image-20220527110837015" /></p>

<p>handle_pcid</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">先通过</span><span class="n">vmread</span><span class="err">读</span><span class="n">VMX_INSTRUCTION_INFO</span><span class="err">即</span><span class="n">VM</span><span class="o">-</span><span class="n">Exit</span> <span class="n">Instruction</span> <span class="n">Info</span>    
<span class="n">vmx_instruction_info</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VMX_INSTRUCTION_INFO</span><span class="p">);</span>

<span class="err">再获取造成</span><span class="n">VM</span><span class="o">-</span><span class="n">Exit</span><span class="err">的指令的参数，这里获取第二个参数即上面的</span><span class="n">Operand</span> <span class="mi">2</span><span class="err">，这里总感觉应该是第一个参数，难道是因为函数压栈的原因，最后一个参数先压栈</span>
<span class="n">gpr_index</span> <span class="o">=</span> <span class="n">vmx_get_instr_info_reg2</span><span class="p">(</span><span class="n">vmx_instruction_info</span><span class="p">);</span>

<span class="err">获取寄存器中的值，可以得到</span><span class="n">Operand1</span><span class="err">中的值，即虚拟机内执行</span><span class="n">invpcid</span><span class="err">时的参数</span><span class="n">type</span>
    <span class="n">type</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpr_index</span><span class="p">);</span>
    <span class="n">VMX_INSTRUCTION_INFO</span>            <span class="o">=</span> <span class="mh">0x0000440e</span><span class="p">,</span>

<span class="err">获取内存参数</span><span class="n">Operand2</span><span class="err">，放入</span><span class="n">gva</span><span class="err">中</span>
<span class="n">get_vmx_mem_address</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmx_get_exit_qual</span><span class="p">(</span><span class="n">vcpu</span><span class="p">),</span>   <span class="n">gva</span><span class="p">);</span>

<span class="err">调用</span>
<span class="n">kvm_handle_invpcid</span><span class="err">执行操作</span>
                    
         
</code></pre></div></div>

<p><img src="PCID.assets/VM-EXIT-INSTRUCTION-INFO.png" alt="image-20220527112513381" /></p>

:ET